import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Generate or load your data (X)

# Define a range of possible cluster numbers
k_values = range(1, 11)  # You can adjust this range as needed

# Calculate the within-cluster sum of squares (WCSS) for each k
wcss = []
for k in k_values:
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(X)
    wcss.append(kmeans.inertia_)

# Find the optimal number of clusters (the "elbow" point)
# We'll automate this by looking for the point where the WCSS starts to flatten out
optimal_k = 1  # Default to 1 cluster
for i in range(1, len(wcss) - 1):
    if (wcss[i] - wcss[i - 1]) / (wcss[i + 1] - wcss[i]) < 0.5:
        optimal_k = i + 1  # Adding 1 to convert to 1-based indexing

print("Optimal number of clusters:", optimal_k)