from sklearn.cluster import MiniBatchKMeans, DBSCAN, AgglomerativeClustering
import matplotlib.pyplot as plt

# Load and preprocess your real-world client data
df = pd.read_csv('your_client_data.csv')

# Feature selection and preprocessing
features = df[['Net Worth ($)', 'Investable Assets ($)']].fillna(0)
scaler = StandardScaler()
scaler.fit(features)
scaled_data = scaler.transform(features)

# Define the clustering algorithms
kmeans = MiniBatchKMeans(n_clusters=3, batch_size=100, random_state=0)
dbscan = DBSCAN(eps=0.5, min_samples=5)
agg_clustering = AgglomerativeClustering(n_clusters=3)

# Run each clustering algorithm
kmeans_clusters = kmeans.fit_predict(scaled_data)
dbscan_clusters = dbscan.fit_predict(scaled_data)
agg_clusters = agg_clustering.fit_predict(scaled_data)

# Create an ensemble by stacking the results of clustering algorithms
ensemble_labels = np.vstack((kmeans_clusters, dbscan_clusters, agg_clusters)).T

# Perform majority voting to assign data points to clusters
voting_labels = []
for row in ensemble_labels:
    unique_labels, counts = np.unique(row, return_counts=True)
    majority_label = unique_labels[np.argmax(counts)]
    voting_labels.append(majority_label)

# Identify outliers based on DBSCAN
outliers = dbscan_clusters == -1

# Visualize the ensemble clusters with outliers
plt.figure(figsize=(8, 6))
plt.scatter(features['Net Worth ($)'], features['Investable Assets ($)'], c=voting_labels, cmap='viridis')
plt.scatter(features['Net Worth ($)'][outliers], features['Investable Assets ($)'][outliers], c='red', marker='x', label='Outliers')
plt.title('Ensemble Clusters with Outliers (Red "x")')
plt.legend()
plt.show()