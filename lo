import tensorflow as tf
import numpy as np
from sklearn.model_selection import train_test_split

# Constants
NUM_DAYS = 14
NUM_FEATURES = 22
NUM_CLASSES = 3
NUM_UNITS = 64
BATCH_SIZE = 64
NUM_EPOCHS = 20

# Prepare the data
X_train, X_test, y_train, y_test = train_test_split(X_train, y_train, test_size=0.2, random_state=42)

# Create the LTCCell
ltc_cell = LTCCell(num_units=NUM_UNITS)

# Placeholder for input and target
input_placeholder = tf.placeholder(shape=[None, NUM_DAYS, NUM_FEATURES], dtype=tf.float32)
target_placeholder = tf.placeholder(shape=[None], dtype=tf.int32)

# Map inputs using the LTCCell
inputs_mapped = ltc_cell._map_inputs(input_placeholder)

# Unstack the inputs to feed into the LSTM cell
inputs_unstacked = tf.unstack(inputs_mapped, axis=1)

# LSTM cell implementation
outputs, _ = tf.nn.static_rnn(ltc_cell, inputs_unstacked, dtype=tf.float32)

# Flatten the LSTM outputs for classification
final_output = tf.layers.dense(outputs[-1], NUM_CLASSES)

# Define the loss and optimizer
loss = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target_placeholder, logits=final_output))
optimizer = tf.train.AdamOptimizer(learning_rate=0.001).minimize(loss)

# Accuracy metric
predictions = tf.argmax(final_output, axis=1)
accuracy = tf.reduce_mean(tf.cast(tf.equal(predictions, target_placeholder), tf.float32))

# Training loop
with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())

    num_batches = X_train.shape[0] // BATCH_SIZE
    for epoch in range(NUM_EPOCHS):
        total_loss = 0
        for batch in range(num_batches):
            batch_indices = np.random.choice(X_train.shape[0], BATCH_SIZE)
            X_batch = X_train[batch_indices]
            y_batch = y_train[batch_indices]

            _, batch_loss = sess.run([optimizer, loss], feed_dict={input_placeholder: X_batch, target_placeholder: y_batch})
            total_loss += batch_loss

        avg_loss = total_loss / num_batches
        train_acc = sess.run(accuracy, feed_dict={input_placeholder: X_train, target_placeholder: y_train})
        test_acc = sess.run(accuracy, feed_dict={input_placeholder: X_test, target_placeholder: y_test})
        print(f"Epoch {epoch + 1}/{NUM_EPOCHS}, Loss: {avg_loss:.4f}, Train Accuracy: {train_acc:.4f}, Test Accuracy: {test_acc:.4f}")

    # Save the model if needed
    saver = tf.train.Saver()
    saver.save(sess, 'ltc_model')

    # Make predictions
    test_predictions = sess.run(predictions, feed_dict={input_placeholder: X_test})

# Interpret the predictions (1 for buy, 0 for hold, -1 for sell)
print("Test Predictions:")
for pred in test_predictions:
    if pred == 1:
        print("Buy")
    elif pred == 0:
        print("Hold")
    else:
        print("Sell")

