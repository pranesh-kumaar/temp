def calculate_ideal_position(data):

    df = data.copy()

    # Calculate rate of change (ROC)
    df['ROC'] = df['Adj Close'].pct_change()
    
    # Define a function to dynamically adjust the window size based on ROC
    def dynamic_window_size(roc):
        if (roc < 0.01).all():
            return 1
        elif ((0.01 <= roc) & (roc < 0.012)).any():
            return 2
        elif ((0.012 <= roc) & (roc < 0.016)).any():
            return 4
        else:
            return 7
    
    # Identify peaks and troughs with dynamically adjusted window size
    df['Peak'] = df['Adj Close'].iloc[argrelextrema(df['Adj Close'].values, comparator=lambda x, y: x > y, order=dynamic_window_size(df['ROC']))[0]]
    df['Trough'] = df['Adj Close'].iloc[argrelextrema(df['Adj Close'].values, comparator=lambda x, y: x < y, order=dynamic_window_size(df['ROC']))[0]]
    
    # Initialize the 'test_signals' list
    signals = [0] * len(df)
    
    # Generate buy and sell signals
    buy_indices = [df.index.get_loc(idx) for idx in df.index[df['Trough'].notnull()]]
    sell_indices = [df.index.get_loc(idx) for idx in df.index[df['Peak'].notnull()]]
    
    for idx in buy_indices:
        signals[idx] = 1
    
    for idx in sell_indices:
        signals[idx] = -1

    return signals 





import matplotlib.pyplot as plt

data = yf.download('INDIANB.NS', start='2022-05-01', end='2022-12-24')
data = gen_ind(data)

test_signals = neat_run.calculate_ideal_position(data)

# Plot the data with buy and sell signals
test_daily_returns, test_cumulative_returns, test_final_return = neat_run.calculate_return(data, test_signals)
adj_close = data['Adj Close']
print("Cumulative Final Return on Test Data:", test_final_return, " Buy and Hold Return: " + str(adj_close[-1] / adj_close[14] - 1))
plot.plot(data, test_signals, test_cumulative_returns)
